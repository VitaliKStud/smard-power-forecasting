
```{r setup, include=FALSE}

# Load Packages
library(fhswf)
library(ggplot2)
library(tsibbledata) #0.4.1
library(dplyr)
library(tsibble)
library(fable)
library(fabletools)
library(feasts)
library(distributional)
library(lubridate)
library(broom)
library(readr)
library(tidyr)
library(datasets)
library(forecast)
library(timeDate)
library(qlcal)
library(lubridate)
library(devtools)
load_all()
```


# Notizen

- Erwähnen von Saisonallen Pattern für stündliche Daten meisten Täglich, Wöchentlich und jährlich

```{r, echo=TRUE, message=FALSE}

# Load german holidays from 2015 to 2024
german_holidays <- load_german_holidays(from_year = 2015, to_year = 2024)
holiday_to_filter <- as.Date(german_holidays$date)

```



```{r, echo=TRUE, message=FALSE}

# Datensatz zum VERBRAUCH laden
e_consum <- read.csv2(file = "dataset\\stunde_2015_2024\\Realisierter_Stromverbrauch_201501010000_202407090000_Stunde.csv")

# Spalten umbenennen
names(e_consum) <- c("DatumVon",
                     "DatumBis",
                     "Netzlast",
                     "Residuallast",
                     "Pumpspeicher")

# Zählen von fehlenden Werten
total_na <- sum(is.na(e_consum))

# Datensatz ins richtige Format brignen und wenn notwendig filtern
load_e_consum <- function(filter = FALSE) {
  e_consum <- e_consum |>
    mutate(
      DatumVon = dmy_hm(DatumVon),
      DatumBis = dmy_hm(DatumBis),
      DatumIndex = DatumVon
    ) |>
    group_by(DatumIndex) |>
    slice(1) |>
    ungroup() |>
    mutate(
      Netzlast = as.numeric(gsub(",", ".", gsub(
        "\\.", "", Netzlast
      ))),
      Residuallast = as.numeric(gsub(",", ".", gsub(
        "\\.", "", Residuallast
      ))),
      Pumpspeicher = as.numeric(gsub(",", ".", gsub(
        "\\.", "", Pumpspeicher
      ))),
    ) |>
    as_tsibble(index = DatumIndex) |>
    select(DatumVon, DatumBis, Netzlast, Residuallast, Pumpspeicher) |>
    fill_gaps()
  
  if (filter) {
    e_consum <- e_consum |>
      filter(year(DatumIndex) >= 2015 & year(DatumIndex) <= 2016)
  }
  return(e_consum)
}
e_consum <- load_e_consum(filter = FALSE)

# Lambda ermitteln und rausholen
lambda <- e_consum |>
  features(Netzlast, features = guerrero) |>
  pull(lambda_guerrero)

e_consum_transformed <- e_consum |>
  mutate(Transformed = box_cox(Netzlast, lambda))

e_consum_transformed |>
  features(difference(Netzlast, lag = 168), unitroot_nsdiffs)

e_consum_transformed |>
  features(difference(difference(Netzlast, lag = 168), differences = 1), unitroot_ndiffs)

e_consum_transformed <- e_consum_transformed |>
  mutate(Netzlast = difference(difference(Netzlast, lag = 168), differences =
                                 1))

e_consum_transformed |>
  gg_tsdisplay(Netzlast, plot_type = "partial", lag = 168)

# Plot
autoplot(e_consum, Netzlast) +
  theme_minimal()


elec <- e_consum |>
  mutate(
    Wochentag = wday(DatumVon, label = TRUE),
    Arbeitstag = !Holiday & !(DOW %in% c("Sat", "Sun")),
  )
  
```

```{r, echo=TRUE, message=FALSE}


elec <- e_consum %>%
  mutate(
    Wochentag = wday(DatumVon, label = TRUE),  
    Date = as.Date(DatumVon),
    Year = as.factor(year(Date)),
    Arbeitstag = !(Date %in% holiday_to_filter | Wochentag %in% c("Sa", "So"))
    ) |>
  filter(Year=="2015" |Year == "2016")

elec |>
  ggplot(aes(x=Year, y=Netzlast, col=Arbeitstag)) +
  geom_boxplot()
  

fit <- elec |>
  fill_gaps() |>
  model(
    ARIMA(Netzlast ~ PDQ(0, 0, 0) + pdq(d = 0) + Arbeitstag +
          fourier(period = "day", K = 10) +
          fourier(period = "week", K = 5) +
          fourier(period = "year", K = 3))
  )


```

```{r, echo=TRUE, message=FALSE}


elec <- e_consum %>%
  mutate(
    Wochentag = wday(DatumVon, label = TRUE),  
    Date = as.Date(DatumVon),
    Year = as.factor(year(Date)),
    Arbeitstag = !(Date %in% holiday_to_filter | Wochentag %in% c("Sa", "So"))
    ) |>
  filter(Year=="2015" |Year == "2016")

elec |>
  ggplot(aes(x=Year, y=Netzlast, col=Wochentag)) +
  geom_boxplot()
  


```

```{r, echo=TRUE, message=FALSE}

data_2016 <- e_consum |>
  filter(year(DatumVon) == 2017) |>
  filter(month(DatumVon) == 1) |>
  filter(day(DatumVon) > 0)

elec_newdata <- new_data(elec, 30*24) |>
  mutate(
    Date = as.Date(DatumIndex),
    Wochentag = wday(Date, label = TRUE),  
    Arbeitstag = !(Date %in% holiday_to_filter | Wochentag %in% c("Sa", "So"))
  )

fc <- fit |>
  forecast(new_data = elec_newdata)


fc |>
  autoplot(elec |> tail(30 * 24)) + 
  geom_line(data = data_2016,
  aes(x = DatumVon, y = Netzlast, color ="Testdatensatz"))

fit |> gg_tsresiduals()

glance(fit)
report(fit)
```



